---
title: "Part 2"
format:
  revealjs:
    incremental: true
jupyter: ds3
execute:
  cache: true
echo: true
eval: true
output-location: fragment
---

# About `pandas`

## ðŸ¼ ?

- Popular library for analyzing _tabular data_.
	- Tabular: rectangular, has rows and columns.
- _Expressive_ and _full-featured_.
	- Readable syntax
	- Lots of convenience functions

. . . 

ðŸ¼: _panel data, apparently._ ^[https://www.dlr.de/sc/Portaldata/15/Resources/dokumente/pyhpc2011/submissions/pyhpc2011_submission_9.pdf]


## Pros and Cons

:::: {.columns}

::: {.column}
**Reasons to use**

- Support for **many** file types
- Integrated into data analysis ecosystem
- Balance of verbosity and function
- Complex time-series and hierarchically indexed data functionality
:::

::: {.column}
**Reasons not to use**

- Struggles with larger datasets (>1M rows)
- Significant overhead
- Memory-intensive
- CPU-only
:::

::::



## Functionality Covered Today

- File I/O (reading/writing data formats)
- Data types, NA
- Indexing, slicing, filtering
- Operations on data
- GroupBy operations
- Combining/merging data

::: {.notes}
- Reduction: array-to-point
- Mapping: same operation on all elements of an array
:::

# Aside: Importing Libraries

## `import`

- To use functionality from other libraries, we need to `import` them.

. . .

```{python}
import pandas
%who
```

## `import`

- Unlike `R`, the default approach is not to import everything into the global namespace.
- Compare:

. . .

```{python}
# This is a bit insane
from pandas import *
%who
```

```{python}
#| echo: false
%reset -f
```

## Aliased Imports

- We can rename modules as we import them:

. . .

```{python}
import pandas as pd
```

- NB: try to stick to abbreviations you see others use!


# Getting Your Data

## Building a `DataFrame`

```{python}
#| echo: true
#| eval: true
df_scores = pd.DataFrame({
    'student_id': ['5a01', '5a12', '5b05', '5b10', '5e04'],
    'math':    [95, 78, 85, 90, 88],
    'english': [97, 91, 86, 89, 90],
    'history': [80, 89, 94, 87, 85],
    'biology': [81, 86, 88, 99, 88],
    'art':     [86, 81, 82, 91, 84],
})
df_scores
```


## Data IO: `read_csv`

. . .

```{python}
#| echo: true
#| eval: true
df = pd.read_csv("data/scores.csv")
df
```


<!-- ```{python}
#| echo: false
#| eval: true
df = pd.read_csv("data/scores.csv")
from IPython.display import HTML
HTML("figures/pandas_base.html")
``` -->


# Accessing Data

- Core operation is to "select" elements from data frame.

## Columns and Index

- Entries indexed by columns and rows
- These can be accessed through following:

. . .

```{python }
#| output-location: column-fragment
df.columns
```
. . .

```{python}
#| output-location: column-fragment
df.index
```

- By default dataframes have a numerical index.

## Setting the Index

- For this demonstration we will use a more meaningful one.

. . .

```{python}
#| output-location: column-fragment
df = df.set_index('student_id')
df.index
```

<!-- 
##

Now our dataframe looks like this:

. . .

```{python}
#| eval: false
df
``` -->

. . .

```{python}
#| echo: false
from IPython.display import HTML
HTML("figures/pandas_base.html")
```


## `.loc`

- Use `.loc` for name-based indexing.
- General syntax: `.loc[<INDEX>, <COLS>]`
	- `<INDEX>` and `<COLS>` correspond to the index and column names.
	- They can be a single value, a list, or `:` to indicate "all".
- Let's learn by example:

## Row

. . .

We select a row by passing the label for the corresponding row to the first argument:

. . .

```{python}
#| eval: false
df.loc['5a01', :]
```

. . .

```{python}
#| echo: false
#| eval: true
HTML("figures/pandas_loc_row.html")
```

<!-- ## Equivalent Syntax

The following are also equivalent:

```{python}
#| echo: true
#| eval: false
df.loc['5a01'] # First argument implicitly rows
df.loc['5a01', :] # `:` means "all"
df.loc['5a01', df.columns] # `df.columns`
df.loc[df.index[0], df.columns]
```

. . .

```{python}
#| echo: false
#| eval: true
HTML("figures/pandas_loc_row.html")
``` -->


## Column

. . .

Similarly, we select a column by passing the label for the corresponding column to the second argument:

. . .

```{python}
#| eval: false
df.loc[:, 'history']
```

. . .

```{python}
#| echo: false
HTML("figures/pandas_loc_col.html")
```

## Multiple Rows

. . .

We select multiple rows by passing a list of labels:

. . .

```{python}
#| eval: false
df.loc[['5a01', '5a12'], :]
```

. . .

```{python}
#| echo: false
HTML("figures/pandas_loc_multi_row.html")
```

## Multiple Columns

. . .

Again, columns work the same way

. . .

```{python}
#| eval: false
df.loc[:, ['art', 'history']]
```

. . .

```{python}
#| echo: false
HTML("figures/pandas_loc_multi_col.html")
```

## Label Order

Note the order of labels changes the order of columns:

. . .

```{python}
df.loc[:, ['art', 'history']]
```

## Cell

. . .

We can select a specific cell by passing its corresponding index and column labels:

. . .

```{python}
#| eval: false
df.loc['5a01', 'history']
```

. . .

```{python}
#| echo: false
#| eval: true
HTML("figures/pandas_loc_cell.html")
```

## Multiple Values

. . .

We can select a multiple cells like so:

. . .

```{python}
#| eval: false
df.loc['5a12', ['history', 'art']]
```

. . .

```{.python}
#| echo: false
#| eval: true
HTML("figures/pandas_loc_multi1.html")
```


## cont.

. . .

```{.python}
#| eval: false
df.loc[['5a01', '5a12', '5b05'], ['biology', 'art']]
```

. . .

```{.python}
#| echo: false
#| eval: true
HTML("figures/pandas_loc_multi2.html")
```

## Filtering

- Selecting values based on a logical condition
- e.g. students with a `math` score $\ge$ 90
- First construct a filter:

. . .

```{python}
#| output-location: column-fragment
df.loc[:, 'math'] >= 90
```

## Filtering

- Now pass it to `.loc`

. . .

```{python}
#| code-line-numbers: "2"
good_math = df.loc[:, 'math'] >= 90
df.loc[good_math, :]
```

## Filtering

- This can be done in one line:

. . .

```{python}

df.loc[df.loc[:, 'math']>=(90), :]
```

# Operations

## 